{"version":3,"file":"index.mjs","sources":["../lib/ndarray.js","../lib/zsumkbn.js","../lib/main.js"],"sourcesContent":["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport reinterpret from '@stdlib/strided-base-reinterpret-complex128';\nimport Complex128 from '@stdlib/complex-float64-ctor';\nimport abs from '@stdlib/math-base-special-abs';\n\n\n// MAIN //\n\n/**\n* Computes the sum of double-precision complex floating-point strided array elements using an improved Kahan–Babuška algorithm.\n*\n* ## Method\n*\n* -   This implementation uses an \"improved Kahan–Babuška algorithm\", as described by Neumaier (1974).\n*\n* ## References\n*\n* -   Neumaier, Arnold. 1974. \"Rounding Error Analysis of Some Methods for Summing Finite Sums.\" _Zeitschrift Für Angewandte Mathematik Und Mechanik_ 54 (1): 39–51. doi:[10.1002/zamm.19740540106](https://doi.org/10.1002/zamm.19740540106).\n*\n* @param {PositiveInteger} N - number of indexed elements\n* @param {Complex128Array} x - input array\n* @param {integer} strideX - stride length\n* @param {NonNegativeInteger} offsetX - starting index\n* @returns {Complex128} sum\n*\n* @example\n* import Complex128Array from '@stdlib/array-complex128';\n*\n* var x = new Complex128Array( [ 1.0, -2.0, 2.0, 3.0 ] );\n*\n* var v = zsumkbn( x.length, x, 1, 0 );\n* // returns <Complex128>[ 3.0, 1.0 ]\n*/\nfunction zsumkbn( N, x, strideX, offsetX ) {\n\tvar rsum;\n\tvar isum;\n\tvar sx;\n\tvar ix;\n\tvar vr;\n\tvar vi;\n\tvar tr;\n\tvar ti;\n\tvar cr;\n\tvar ci;\n\tvar i;\n\tvar j;\n\tvar k;\n\n\tif ( N <= 0 ) {\n\t\treturn new Complex128( 0.0, 0.0 );\n\t}\n\tx = reinterpret( x, 0 );\n\tix = offsetX * 2;\n\tif ( strideX === 0 ) {\n\t\treturn new Complex128( N * x[ ix ], N * x[ ix+1 ] );\n\t}\n\tsx = strideX * 2;\n\n\tvr = x[ ix ];\n\tvi = x[ ix+1 ];\n\trsum = vr;\n\tisum = vi;\n\n\t// In order to preserve the sign of zero which can be lost during compensated summation below, find the first non-zero components...\n\tif ( vr === 0.0 || vi === 0.0 ) {\n\t\tj = -1;\n\t\tk = -1;\n\t\tfor ( i = 0; i < N; i++ ) {\n\t\t\tif ( j < 0 ) {\n\t\t\t\tvr = x[ ix ];\n\t\t\t\tif ( vr === 0.0 ) {\n\t\t\t\t\trsum += vr;\n\t\t\t\t} else {\n\t\t\t\t\tj = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( k < 0 ) {\n\t\t\t\tvi = x[ ix+1 ];\n\t\t\t\tif ( vi === 0.0 ) {\n\t\t\t\t\tisum += vi;\n\t\t\t\t} else {\n\t\t\t\t\tk = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( j >= 0 && k >= 0 ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tix += sx;\n\t\t}\n\t} else {\n\t\tj = 0;\n\t\tk = 0;\n\t}\n\t// Reset the pointer:\n\tix = ( offsetX * 2 ) + sx;\n\n\t// Initialize correction terms:\n\tcr = 0.0;\n\tci = 0.0;\n\n\tfor ( i = 1; i < N; i++ ) {\n\t\tif ( i >= j ) {\n\t\t\tvr = x[ ix ];\n\t\t\ttr = rsum + vr;\n\t\t\tif ( abs( rsum ) >= abs( vr ) ) {\n\t\t\t\tcr += (rsum-tr) + vr;\n\t\t\t} else {\n\t\t\t\tcr += (vr-tr) + rsum;\n\t\t\t}\n\t\t\trsum = tr;\n\t\t}\n\t\tif ( i >= k ) {\n\t\t\tvi = x[ ix+1 ];\n\t\t\tti = isum + vi;\n\t\t\tif ( abs( isum ) >= abs( vi ) ) {\n\t\t\t\tci += (isum-ti) + vi;\n\t\t\t} else {\n\t\t\t\tci += (vi-ti) + isum;\n\t\t\t}\n\t\t\tisum = ti;\n\t\t}\n\t\tix += sx;\n\t}\n\tif ( j >= 0 ) {\n\t\trsum += cr;\n\t}\n\tif ( k >= 0 ) {\n\t\tisum += ci;\n\t}\n\treturn new Complex128( rsum, isum );\n}\n\n\n// EXPORTS //\n\nexport default zsumkbn;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport stride2offset from '@stdlib/strided-base-stride2offset';\nimport ndarray from './ndarray.js';\n\n\n// MAIN //\n\n/**\n* Computes the sum of double-precision complex floating-point strided array elements using an improved Kahan–Babuška algorithm.\n*\n* ## Method\n*\n* -   This implementation uses an \"improved Kahan–Babuška algorithm\", as described by Neumaier (1974).\n*\n* ## References\n*\n* -   Neumaier, Arnold. 1974. \"Rounding Error Analysis of Some Methods for Summing Finite Sums.\" _Zeitschrift Für Angewandte Mathematik Und Mechanik_ 54 (1): 39–51. doi:[10.1002/zamm.19740540106](https://doi.org/10.1002/zamm.19740540106).\n*\n* @param {PositiveInteger} N - number of indexed elements\n* @param {Complex128Array} x - input array\n* @param {integer} strideX - stride length\n* @returns {Complex128} sum\n*\n* @example\n* import Complex128Array from '@stdlib/array-complex128';\n*\n* var x = new Complex128Array( [ 1.0, -2.0, 2.0, 3.0 ] );\n*\n* var v = zsumkbn( x.length, x, 1 );\n* // returns <Complex128>[ 3.0, 1.0 ]\n*/\nfunction zsumkbn( N, x, strideX ) {\n\treturn ndarray( N, x, strideX, stride2offset( N, strideX ) );\n}\n\n\n// EXPORTS //\n\nexport default zsumkbn;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport setReadOnly from '@stdlib/utils-define-nonenumerable-read-only-property';\nimport zsumkbn from './zsumkbn.js';\nimport ndarray from './ndarray.js';\n\n\n// MAIN //\n\nsetReadOnly( zsumkbn, 'ndarray', ndarray );\n\n\n// EXPORTS //\n\nexport default zsumkbn;\n"],"names":["zsumkbn","N","x","strideX","offsetX","rsum","isum","sx","ix","vr","vi","tr","ti","cr","ci","i","j","k","Complex128","reinterpret","abs","ndarray","stride2offset","setReadOnly"],"mappings":";;0gBAsDA,SAASA,EAASC,EAAGC,EAAGC,EAASC,GAChC,IAAIC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EAEJ,GAAKhB,GAAK,EACT,OAAO,IAAIiB,EAAY,EAAK,GAI7B,GAFAhB,EAAIiB,EAAajB,EAAG,GACpBM,EAAe,EAAVJ,EACY,IAAZD,EACJ,OAAO,IAAIe,EAAYjB,EAAIC,EAAGM,GAAMP,EAAIC,EAAGM,EAAG,IAU/C,GARAD,EAAe,EAAVJ,EAILE,EAFAI,EAAKP,EAAGM,GAGRF,EAFAI,EAAKR,EAAGM,EAAG,GAKC,IAAPC,GAAqB,IAAPC,EAGlB,IAFAM,GAAK,EACLC,GAAK,EACCF,EAAI,EAAGA,EAAId,IACXe,EAAI,IAEI,KADZP,EAAKP,EAAGM,IAEPH,GAAQI,EAERO,EAAID,GAGDE,EAAI,IAEI,KADZP,EAAKR,EAAGM,EAAG,IAEVF,GAAQI,EAERO,EAAIF,KAGDC,GAAK,GAAKC,GAAK,IAjBDF,IAoBnBP,GAAMD,OAGPS,EAAI,EACJC,EAAI,EASL,IANAT,EAAiB,EAAVJ,EAAgBG,EAGvBM,EAAK,EACLC,EAAK,EAECC,EAAI,EAAGA,EAAId,EAAGc,IACdA,GAAKC,IAETL,EAAKN,GADLI,EAAKP,EAAGM,IAEHY,EAAKf,IAAUe,EAAKX,GACxBI,GAAOR,EAAKM,EAAMF,EAElBI,GAAOJ,EAAGE,EAAMN,EAEjBA,EAAOM,GAEHI,GAAKE,IAETL,EAAKN,GADLI,EAAKR,EAAGM,EAAG,IAENY,EAAKd,IAAUc,EAAKV,GACxBI,GAAOR,EAAKM,EAAMF,EAElBI,GAAOJ,EAAGE,EAAMN,EAEjBA,EAAOM,GAERJ,GAAMD,EAQP,OANKS,GAAK,IACTX,GAAQQ,GAEJI,GAAK,IACTX,GAAQQ,GAEF,IAAII,EAAYb,EAAMC,EAC9B,CCnGA,SAASN,EAASC,EAAGC,EAAGC,GACvB,OAAOkB,EAASpB,EAAGC,EAAGC,EAASmB,EAAerB,EAAGE,GAClD,CCzBAoB,EAAAvB,EAAA,UAAAqB"}